# Programming Glossary
Programming is the breeding ground for crazy words and phrases that make no sense to non-programmers. It would be a disservice
to you if I simply smoothed out all the lingo so that you could understand it without the buzzwords, because people genuinely use
buzzwords in the industry. Since that is the case, I have opted to include a glossary here, that can be linked back to, so that
when a new or difficult term shows up, you can pause briefly and familiarize yourself with the concept here.

## Git
Git is a program - a piece of software. It's not a website and it's not a **repository**. It is a software that is used to create **repositories** which can be hosted on a website like GitHub (which is where this course lives). Git does not show up on your computer like a normal program does, like the Calculator or Notepad, but it is neverthelessa program. There is an entire class of programs that you don't see on your computer, Git is not really unique in that way. It's hard to give examples of these programs because for the most part, if you don't write code, you probably don't use them. An example would be SSH, which is a program that lets you securely send files to another server, or Docker, which is used to package apps into self-contained deployable containers. Git is operated either through the terminal or by using an application which leverages it in the background, like GitHub Desktop.

### Branch
Every **repository** starts with a single **branch**, or a single version of reality, usually called either "main" or "master". Additional **branches** are like alternate realities where one or two things were done differently and things ran their course. Imagine you have a **repository** that stores the files for your personal website (hey, that's what this **repository** does...). Now imagine that in your "main" **branch** you have a banner that goes across the top with a green background. Now imagine that you've heard from some of your friends that green is _boring_, and you're considering changing the color to something more lively, like orange. You could create a **branch** and call it "pizzaz_renovation" (**branch** names can't have spaces) and in that **branch**, you add a **commit** (a set of changes) that changes every banner on your website to make them orange. Now you still have your main **branch** with green banners, but you ALSO have another reality where the banners are orange. Down the road, you may decide that you agree with your friends and you can **merge** that **branch** into the main **branch**, and then the banners in the main **branch** will be orange. You could also decide that you don't really care what your friends think, and delete that **branch**, keeping your banners green in your main branch.

### Cloning
**Cloning** is copying the contents of a **repository** on your computer. This is similar to **forking** which creates a copy of a **repository** in your account on the website/platform you are using (GitHub, GitLab, etc). **Cloning** is the process of copying the entire **repository** from the website or platform onto your computer so that you can begin making changes. **Cloning** is the second step in making contributions to another person's **repository** because it sets up the code on your machine so that you can make changes and then also test that you haven't broken things before asking to **merge** your code back in (called a **Pull Request** or a **Merge Request**).

### Commit
No, this is not the thing we were all afraid of doing in high school (unless you were super nerdy like me). A **commit** is a collection of changes that you want to make to one of the alternate realities (**branches**) in a repository. When you open a file in a normal folder and make a change, you will see the last updated date change to the current time. A **commit** is a change like that, but possibly multiple files that are all being changed at the exact same time (in git's eyes, you make them normally). You make the changes individually, and then you create a **commit** to bundle all the changes together before submitting that change (**pushing**) to the **repository**.

### Fork
A **fork** is a copy of a **repository**. Much like if you copy a file on your computer and send it to someone, that person only gets the contents of the file at the time you sent it, and if you add things to your copy down the road, the person you sent the file will still have the original unchanged copy. In the same way, if you wanted to create a copy of a **repository**, you would **fork** it, which will create a copy of the **repository** in your account on whichever website you are using (GitHub, GitLab, etc). **Forking** is the first step in making contributions to another person's repository, because it gives you an isolated copy where you can introduce changes before sending them on to be included back in the original **repository** (a process called **merging**).

### Merge
**Merging** is taking the code from one **branch** (alternate reality), and combining it with the code from another **branch**. **Merges** can take place between two **branches** in a single **repository**, or between two **branches** in separate **repositories**. When a merge takes place, git (the software program) will look at each line in each file that is being changed, and will keep the line that has changed from the original. This can lead to problems, because potentially someone else has changed the line you are trying to change without telling you, in which case you have a **conflict** which is where git is unsure which change is supposed to be kept. In the case of a **conflict**, git will ask you to tell it which things to keep and which things to get rid of.

### Push
**Pushing** copies your **commit** (the changes you made) up to the non-local copy of your **repository**. **Pushing** is the key connection between the copy of the **repository** you have in GitHub (or some other website) and the copy on your computer that you **cloned**.
The workflow might look like this:
1. You **clone** a **forked** **repository** onto your computer so that you have a local copy of all the files.
2. You make changes to the code in the local copy of the **repository**.
3. You **commit** the changes that you want to keep to your local copy of the **repository**.
4. You **push** your **commit**, which makes a copy of that **commit** directly on your **upstream** (The **repository** that was cloned from).
5. (Optionally) You then open a **Pull Request** (GitHub) or **Merge Request** (GitLab) to the **repository** you **forked** (if you **forked** an existing repository instead of creating a new one from scratch) and wait for a maintainer (a person who helps control what goes into a **repository**) to approve your request and add those commits to their **repository**.

**Pushing** is the next step in making contributions to other **repositories** after you have made changes to files locally.

### Pull/Merge Request
A **pull/merge request** is suggesting a set of **commit(s)** to another **repository** (or another **branch** in the same **repository**). Going back to our multiple copies of a file analogy from earlier, making a **Pull/Merge Request** is essentially the same as asking your coworker to update their copy of the file with the changes that you made to it. Your coworker does not have to agree to use your updated file, and they may say "no" if the changes that you made are bad or incompatible with the work they have done. Making a **Pull/Merge Request** signals to the owner of the original **branch** or **repository** that you have completed some work and would like it to be included in theirs.

### Repository
A **repository** is a collection of code. You might be more familiar with a folder or directory on your computer. A repository is like a folder on your computer, it stores other files and folders. Now, maybe you're wondering: "Why not just call it a folder then?" and that would be a super good question. It turns out the reason is simple: time travel. You read that right. Git is a folder that allows you to time travel by creating **commits** that you can warp back to. It also creates a "multiverse" of sorts, because that one folder actually exists in alternate dimensions (called **branches**) where the things inside the folder are slightly different.

### Checkout
"Checking out" allows you to move the current state of your local **repository** to either match a branch or an exact moment in time when a commit was merged in. Checking out is basically time travelling.
